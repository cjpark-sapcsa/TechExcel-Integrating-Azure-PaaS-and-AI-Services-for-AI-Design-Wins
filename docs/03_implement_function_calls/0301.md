---
title: '1. Prepare an Azure SQL Database'
layout: default
nav_order: 1
parent: 'Exercise 03: Implement function calling'
---

# Task 01 - Prepare an Azure SQL Database (20 minutes)

## Introduction

The Contoso Suites team is interested in learning how they can use Semantic Kernel to extend their application capabilities. The development team is currently responsible for creating any new API endpoints that end users will consume through front-end applications, but a common complaint is that the turnaround time for new API endpoint is too slow. The development team is interested in learning more about Semantic Kernel and whether it could be a viable solution for their problem.

Throughout the course of this exercise, you will complete a simple Web API to support database calls. Then, you will implement a Semantic Kernel plugin to enable arbitrary database query generation (of `SELECT` statements), and display the results as a table in the front-end application.

## Description

In this task, you will load data that Contoso Suites staff has provided to you into Azure SQL DB. This data contains a sample of customer, hotel, and bookings data from their SQL Server-based bookings system. From there, they would like you to implement a .NET Web API endpoint exposing this customer information. They have provided you with most of the code but did not have time to complete the task.

The key tasks are as follows:

1. Add your IP address to your Azure SQL Server's firewall allow list and also enable the **Allow Azure services and resources to access this server** setting.
2. Connect to your remote Azure SQL Database and run the script in `src/data/BookingsHistory.sql` against that database, creating several tables and populating them with sample data.
3. Create an environment variable locally called `AZURE_SQL_DB_CONNECTION_STRING`, containing the connection string for your Azure SQL DB. Use SQL authentication. By default, the user ID is `contosoadmin` and the database name is `ContosoSuitesBookings`. The password is whatever you set it to be in Exercise 1. Be sure to set the `Encrypt` and `TrustServerCertificate` settings to **True**.

    {: .note }
    > After creating an environment variable, you will need to close and re-open your terminal to refresh the list of environment variables. If you are using Visual Studio Code to run this code base, you may need to close and re-open all open instances of VS Code, as instantiating a new terminal might not refresh the list of environment variables.

4. Complete the function mappings in `src/ContosoSuitesWebAPI/Program.cs` for the `/Hotels/` endpoints. Each endpoint should call the relevant database service and return the results of the appropriate method.
5. Build and run the Web API service locally. Connect to the URL provided in the **"Now listening on:"** line and navigate to the `/Hotels` endpoint. For example, if your host is localhost and on port 5292, navigate to `http://localhost:5292/Hotels`. You should see a list of four hotels. Test the other two endpoints as well.
6. Open the Streamlit application and navigate to the **API Integration** page. You should see a drop-down list asking you to select a hotel, followed by a table of bookings for that hotel.

    {: .note }
    > You may need to change the `[api].[endpoint]` key in your `secrets.toml` file to point to your local Web API service, rather than the App Service deployment.

7. Deploy your App Service code changes and ensure they propagate to Azure App Services. Then, add a new connection string to the App Service's environment variables called `AZURE_SQL_DB_CONNECTION_STRING`. The Value should be the value of your connection string and the Type should be **SQLServer**.
8. Test your deployed Streamlit application and ensure that it is able to load the hotels drop-down list and bookings table as expected.

## Success Criteria

- You have created a series of tables in the ContosoSuitesBookings Azure SQL Database.
- You have updated the .NET Web API endpoint to allow querying against hotel and bookings data.

## Tips

- If your .NET application build is failing when you try to run `dotnet run` and you receive an error that the build cannot load the required packages from NuGet, you may be missing a link to the Microsoft NuGet repository. Run the command `dotnet nuget list source` and see if you have an entry enabled for nuget.org. If not, you can add it with the following command: `dotnet nuget add source https://api.nuget.org/v3/index.json -n nuget.org`. If you have one but it is currently disabled, you can enable it with the command `dotnet nuget enable source nuget.org`.

## Learning Resources

TODO!

## Solution

TODO: fill in customer bookings SQL queries
UI can have a table of bookings

<details markdown="block">
<summary>Expand this section to view the solution</summary>

- To create the Cosmos DB container, perform the following steps:
  - In the Azure portal, navigate to the Cosmos DB service associated with your resource group.
  - Select the **Data Explorer** option from the top menu.
  - In the Data Explorer, select the **New Container** button in the middle of the screen.
  - Create a new database and give it a name of `ContosoSuites`. You may safely set the database throughput either to `Autoscale` with a Database Max RU/s of `1000`, or `Manual` with a Database RU/s of `400`.
  - The new Container id should be called `Customers`. Choose a partition key, such as `/FullName` and select **OK** to create the database and container.

    ![Create a new container called Customers](../../media/Solution/0301_NewContainer.png)

- After container creation finishes, import customer data using the Data Explorer:
  - In the Data menu tree for the NoSQL API left-hand menu, drill into **ContosoSuites**, then **Customer**, and finally select the Items menu option.
  - Choose the **Upload Item** menu option. Navigate to where you have saved the file "Customer.json" and upload it.
  - Uploading will succeed and import 77 entries.

    ![Upload the sample customers into Cosmos DB](../../media/Solution/0301_CustomerUpload.png)

- Create an environment variable locally, giving it the name `AZURE_COSMOS_DB_CONNECTION_STRING`. There are several ways to create an environment variable, including `setx` in the Windows command shell, the `$env` variable in PowerShell, and the **Environment Variables** option in the **Advanced** tab of System Properties.

    To perform this in PowerShell, you can run the following command:

    ```powershell
    $env:AZURE_COSMOS_DB_CONNECTION_STRING = 'AccountEndpoint=https://{your_endpoint}.documents.azure.com:443/;AccountKey={your_key};'
    ```

    Should you wish to create an environment variable using the System Properties user interface, it is possible to do this as well.

    ![Creating a new environment variable in Windows](../../media/Solution/0301_EnvironmentVariable.png)

- The final code to support customer lookup should look something like this.
  - Here is the code for the four functions in `CosmosService.cs`:

  ```csharp
  public async Task<IEnumerable<Customer>> GetCustomersByName(string name)
      {
          var queryable = container.GetItemLinqQueryable<Customer>();
          using FeedIterator<Customer> feed = queryable
              .Where(c => c.FullName == name)
              .ToFeedIterator<Customer>();
          return await ExecuteQuery(feed);
      }

      public async Task<IEnumerable<Customer>> GetCustomersByLoyaltyTier(string loyaltyTier)
      {
          LoyaltyTier lt = Enum.Parse<LoyaltyTier>(loyaltyTier);
          var queryable = container.GetItemLinqQueryable<Customer>();
          using FeedIterator<Customer> feed = queryable
              .Where(c => c.LoyaltyTier.ToString() == loyaltyTier)
              .ToFeedIterator<Customer>();
          return await ExecuteQuery(feed);
      }

      public async Task<IEnumerable<Customer>> GetCustomersWithStaysAfterDate(DateTime dt)
      {
          var queryable = container.GetItemLinqQueryable<Customer>();
          using FeedIterator<Customer> feed = queryable
              .Where(c => c.DateOfMostRecentStay > dt)
              .ToFeedIterator<Customer>();
          return await ExecuteQuery(feed);
      }

      private async Task<IEnumerable<Customer>> ExecuteQuery(FeedIterator<Customer> feed)
      {
          List<Customer> results = new();
          while (feed.HasMoreResults)
          {
              var response = await feed.ReadNextAsync();
              foreach (Customer c in response)
              {
                  results.Add(c);
              }
          }
          return results;
      }
  ```

  - Here is the code for Program.cs:

  ```csharp
  app.MapGet("/Customer", async (string searchCriterion, string searchValue) => 
  {
      switch (searchCriterion)
      {
          case "CustomerName":
              return await app.Services.GetService<ICosmosService>()!.GetCustomersByName(searchValue);
          case "LoyaltyTier":
              return await app.Services.GetService<ICosmosService>()!.GetCustomersByLoyaltyTier(searchValue);
          case "DateOfMostRecentStay":
              return await app.Services.GetService<ICosmosService>()!.GetCustomersWithStaysAfterDate(DateTime.Parse(searchValue));
          default:
              throw new Exception("Invalid search criterion. Valid search criteria include 'CustomerName', 'LoyaltyTier', and 'DateOfMostRecentStay'.");
      }
  })
  ```

</details>
