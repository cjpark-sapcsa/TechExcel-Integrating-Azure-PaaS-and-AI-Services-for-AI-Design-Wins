---
title: '2. Create a function call to retrieve bookings information'
layout: default
nav_order: 2
parent: 'Exercise 03: Implement function calling'
---

# Task 02 - Create a function call for the customer account information API endpoint (40 minutes)

## Introduction

Using the Semantic Kernel library, you can translate natural language input into a function call. This allows organizations to extend existing code bases and APIs with a natural language front end.

## Description

In the prior task, you populated bookings history data in Azure SQL Database and built three endpoints on top of it. The Contoso Suites development team would like to continue building API endpoints, but want to take advantage of natural language capabilities to make front-end development easier. In this task, you will use the Semantic Kernel library to make the database service calls into kernel functions that can run based on user request.

The key tasks are as follows:

1. Add three local secrets using `dotnet user-secrets`. They should be named `AzureOpenAI:DeploymentName`, `AzureOpenAI:Endpoint`, and `AzureOpenAI:ApiKey`, and these secret names are case-sensitive.
2. The `DatabaseService` class and `IDatabaseService` interface have three methods associated with them. Contoso Suites would like to add two more methods. One will be called `GetBookingsMissingHotelRooms()` and will return all bookings that do not have associated hotel rooms. The second will be called `GetBookingsWithMultipleHotelRooms()` and will return all bookings with more than one hotel room. Neither method should take an input parameter, and you will not need to add explicit endpoints for these.
3. Add the Semantic Kernel NuGet package to the Web API project.
4. Tag each of the methods in the `DatabaseService` class as kernel functions and provide a description for each method and input parameter.
5. The `AppConfig.cs` file contains a simple configuration class. Update the `Program.cs` file to use this configuration class to build out a configuration. Add in any user secrets associated with the (implicit) `Program` class as well as environment variables, and then validate the configuration.
6. In `Program.cs`, add a singleton of type `Microsoft.SemanticKernel.Kernel`. It should create an `IKernelBuilder` and then add Azure OpenAI chat completion, using the deployment name, endpoint, and API key from your configuration. It should also add as a plugin everything in the `DatabaseService` class.
7. Implement the `/Chat` POST request. It should use the `Kernel` singleton and get chat message content from the chat completion service. Return to the end user `response?.Content!`.
8. Run the Web API project and ensure that things work correctly. You can perform a simple test in PowerShell using the following request.

    ```powershell
    $postParams = @{ message="Which bookings do not currently have hotel rooms associated with them?" }
    Invoke-WebRequest -Uri http://localhost:5292/Chat -Method POST -Body $postParams
    ```

    Change the `-Uri` parameter as needed, if your local port is not 5292.
9. With the Web API package running, run your Streamlit front end and navigate to the **API Integration** page. Ask the following questions and ensure that you get back the results you expect.
   1. Please show me the bookings for hotel 3 for any date later than December 1, 2024.
   2. Which bookings currently do not have hotel rooms assigned to them?
   3. How many bookings have included at least two hotel rooms?
10. Deploy your App Service code changes and ensure they propagate to Azure App Services. Then, add a three new environment variables to the App Service: `AzureOpenAI__DeploymentName`, `AzureOpenAI__Endpoint`, and `AzureOpenAI__ApiKey`. These environment variables should have **two** underscores between "AzureOpenAI" and the name.

    {: .important }
    > In a production environment, it would be better to save these as secrets in Azure Key Vault and then enable a managed identity to access the Key Vault secrets from your App Service. The reason for this is, with the current configuration, anyone with access to manage the App Service can view the deployment name, endpoint, and API key secrets.

11. Test your deployed Streamlit application and ensure that it is able to answer user questions about bookings as expected.

## Success Criteria

- You have added two new methods to the `IDatabaseService` interface and its associated `DatabaseService` class.
- You have implemented the Chat endpoint and can call any of the `DatabaseService` functions.
- You are able to interact with the Chat endpoint from the **API Integration** page in Streamlit.

## Learning Resources

TODO!

- [Booking Restaurant - Demo Application](https://github.com/microsoft/semantic-kernel/tree/main/dotnet/samples/Demos/BookingRestaurant)

## Tips

- The Semantic Kernel .NET library is rapidly changing, and some examples you may find online relate to the old methods for interacting with Semantic Kernel. Furthermore, if you are using GitHub Copilot to assist with development, it may provide you with code that no longer functions with recent versions of Semantic Kernel. Be sure to use recent code examples as guidance.

## Solution

TODO!

<details markdown="block">
<summary>Expand this section to view the solution</summary>

- GPT function definitions are JSON objects following a particular pattern, with a combination of name, description, and parameters. The definition for the `get_customers` function is as follows:

    ```python
    functions = [
        {
            "name": "get_customers",
            "description": "Get a list of customers based on some search criterion.",
            "parameters": {
                "type": "object",
                "properties": {
                    "search_criterion": {"type": "string", "enum": ["CustomerName", "LoyaltyTier", "DateOfMostRecentStay"]},
                    "search_value": {"type": "string"},
                },
                "required": ["search_criterion", "search_value"],
            },
        }
    ]
    ```

- The `handle_chat_prompt_with_functions()` function does three things. First, it echoes the user's prompt to the chat window. After that, it sends the prompt to Azure OpenAI. Finally, it executes the function call that Azure OpenAI returns.
  - The code for the completed `handle_chat_prompt_with_functions()` function is as follows:

    ```python
    # Echo the user's prompt to the chat window
    st.session_state.messages.append({"role": "user", "content": prompt})
    with st.chat_message("user"):
        st.markdown(prompt)

    # Send the user's prompt to Azure OpenAI and display the response
    # The call to Azure OpenAI is handled in create_chat_completion()
    # This function loops through the responses and displays them as they come in.
    # It also appends the full response to the chat history.
    with st.chat_message("assistant"):
        message_placeholder = st.empty()
        full_response = ""
        response = create_chat_completion_with_functions(deployment_name, st.session_state.messages)
        response_message = response.choices[0].message

        # Check if GPT returned a function call
        if response_message.function_call:
            # Get the function name and arguments
            function_name = response_message.function_call.name
            # Verify the function
            if function_name not in available_functions:
                full_response = f"Sorry, I don't know how to call the function `{function_name}`."
            else:
                function_to_call = available_functions[function_name]
                # Verify the function has the correct number of arguments
                function_args = json.loads(response_message.function_call.arguments)
                if check_args(function_to_call, function_args) is False:
                    full_response = f"Sorry, I don't know how to call the function `{function_name}` with those arguments."
                else:
                    # Call the function
                    function_to_call(**function_args)
    st.session_state.messages.append({"role": "assistant", "content": "Table response removed for brevity."})
    ```

- The `create_chat_completion_with_functions()` function reaches out to Azure OpenAI and performs the chat completion, providing it the list of available functions and options.
  - The code for the completed `create_chat_completion_with_functions()` function is as follows:

    ```python
    # Create an Azure OpenAI client. We create it in here because each exercise will
    # require at a minimum different base URLs.
    client = openai.AzureOpenAI(
        base_url=f"{aoai_endpoint}/openai/deployments/{deployment_name}/",
        api_key=aoai_api_key,
        api_version="2023-12-01-preview"
    )
    # Create and return a new chat completion request
    # Be sure to include the "functions" parameter and set "function_call"
    return client.chat.completions.create(
        model=deployment_name,
        messages=[
            {"role": m["role"], "content": m["content"]}
            for m in messages
        ],
        functions=functions,
        function_call="auto",
    )
    ```

- The `get_customers()` function reaches out to ASP.NET Web API and performs the lookup call that you created in Exercise 03, Task 01.
  - The code for the completed `get_customers()` function is as follows. Note that you will want to replace `localhost:5292` with the URL and port of the Web API service you ran as part of Exercise 03, Task 01.

    ```python
    full_server_url = f"http://localhost:5292/Customer/?searchCriterion={search_criterion}&searchValue={search_value}"
    r = requests.get(
        full_server_url,
        headers={"Content-Type": "application/json"}
    )
    if r.status_code == 200:
        return st.write(pd.read_json(r.content.decode("utf-8")))
    else:
        return f"Failure to find any customers with {search_criterion} {search_value}."
    ```

</details>

## Additional Challenges

If you would like to take on an additional challenge, perform the following:

1. Load the contents of Resorts.txt into Cosmos DB in a Resorts collection.
2. Create a Web API endpoint allowing users to search for resorts by name, nation, or amenities.
3. Create a new function in the Streamlit application to support this Web API endpoint.
4. Ask a question of the chat service such as "Which resorts are in Bonaire?"
5. Ask a question of the chat service such as "Which resorts offer a pool?"
